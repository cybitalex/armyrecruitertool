# U.S. Army Recruitment Intake Tool

## Overview

This is a comprehensive recruitment application management system designed for U.S. Army recruitment offices. The application allows recruiters to collect, manage, and track candidate applications through a professional web interface. Built with a React frontend and Express backend, it provides a multi-step intake form for gathering detailed candidate information, a dashboard for viewing and managing applications, and detailed views for individual recruit records.

The system handles sensitive personal information including contact details, educational background, medical history, criminal records, and military preferences. It provides status tracking (pending, approved, rejected) and CRUD operations for application management.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture

**Framework**: React 18 with TypeScript in SPA (Single Page Application) mode

**Routing**: Wouter - lightweight client-side routing library chosen for minimal bundle size and simplicity compared to React Router

**State Management**: 
- TanStack Query (React Query) for server state management, caching, and data synchronization
- React Hook Form for form state management with Zod validation

**UI Component System**:
- Radix UI primitives for accessible, unstyled components (dialogs, dropdowns, select boxes, etc.)
- shadcn/ui architecture - components are copied into the project rather than installed as dependencies, allowing full customization
- Tailwind CSS for styling with a custom design system based on Fluent Design principles
- Custom color system using CSS variables for theme consistency

**Design Philosophy**: 
- Professional, government-appropriate aesthetic following Fluent Design System principles
- Accessibility-first approach (ARIA attributes, keyboard navigation, screen reader support)
- Responsive layout with mobile-first approach
- Typography uses Inter font family for clarity and professionalism

**Key Architectural Decisions**:
- Component aliases configured via TypeScript paths (`@/components`, `@/lib`, etc.) for clean imports
- Centralized API client with automatic error handling and credential management
- Toast notifications for user feedback on all mutations
- Optimistic updates disabled in favor of explicit refetching for data integrity in government context

### Backend Architecture

**Framework**: Express.js with TypeScript running in ESNext module format

**API Design**: RESTful API with conventional CRUD endpoints:
- `GET /api/recruits` - List all applications
- `GET /api/recruits/:id` - Get single application
- `POST /api/recruits` - Create new application
- `PATCH /api/recruits/:id/status` - Update application status
- `DELETE /api/recruits/:id` - Remove application

**Data Validation**: 
- Zod schemas shared between client and server via `@shared` namespace
- Server-side validation on all incoming requests with detailed error responses
- Type safety enforced through Drizzle-Zod integration

**Development Server**: 
- Vite dev server integrated as Express middleware for HMR (Hot Module Replacement)
- Single port development with API and frontend proxied together
- Custom logging middleware for API request tracking

**Error Handling**:
- Centralized error responses with appropriate HTTP status codes
- Zod validation errors return 400 with detailed field-level errors
- Generic 500 errors for unexpected failures

### Data Storage

**ORM**: Drizzle ORM chosen for type-safety and PostgreSQL optimization

**Database**: PostgreSQL (configured via Neon serverless driver for cloud deployment)

**Schema Design**:
- Single `recruits` table with comprehensive fields for all application data
- UUID primary keys generated by PostgreSQL (`gen_random_uuid()`)
- Text fields for flexibility in storing varied-length data
- Date type for date of birth
- Integer types for numeric measurements (height, weight, years of service)
- Status enum stored as text with application-level validation

**Current Implementation**: 
- In-memory storage class (`MemStorage`) implements the storage interface
- Designed for easy swap to Drizzle-based database storage
- UUID generation handled by Node.js crypto module in memory implementation

**Migration Strategy**: 
- Drizzle Kit configured for schema migrations
- Migration files output to `./migrations` directory
- Schema source at `./shared/schema.ts` for sharing between client/server

### External Dependencies

**Database Service**: 
- Neon Serverless PostgreSQL (@neondatabase/serverless)
- Connection via DATABASE_URL environment variable
- Serverless-optimized driver for edge deployment compatibility

**UI Component Libraries**:
- Radix UI - 20+ primitive component packages for accessibility
- Embla Carousel - touch-friendly carousel component
- cmdk - Command palette component (likely for future search features)
- Lucide React - Icon library with consistent design language

**Form & Validation**:
- React Hook Form - performant form library with minimal re-renders
- @hookform/resolvers - bridges RHF with Zod validation
- Zod - schema validation library used across client and server
- date-fns - date manipulation and formatting

**Styling**:
- Tailwind CSS - utility-first CSS framework
- class-variance-authority - component variant management
- tailwind-merge & clsx - conditional class name utilities

**Build Tools**:
- Vite - frontend build tool and dev server
- esbuild - server-side bundler for production
- tsx - TypeScript execution for development
- PostCSS with Autoprefixer

**Session Management**:
- connect-pg-simple - PostgreSQL session store for Express (configured but not actively used in current codebase)

**Development Environment**:
- Replit-specific plugins for enhanced development experience
- Runtime error overlay, cartographer navigation, dev banner

**Deployment Considerations**:
- Environment variable `DATABASE_URL` required for database connection
- Build process bundles server and client separately
- Static files served from `dist/public` in production
- Server bundle uses ESM format for modern Node.js compatibility